package export

import (
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/presstronic/recontronic-cli-client/pkg/recon"
)

// ExportToMarkdown exports subdomain results to Markdown format
func ExportToMarkdown(result *recon.SubdomainResults, options ExportOptions) (string, error) {
	filePath := options.OutputPath
	if filePath == "" {
		filePath = fmt.Sprintf("%s_subdomains.md", result.Domain)
	}

	file, err := os.Create(filePath)
	if err != nil {
		return "", fmt.Errorf("failed to create Markdown file: %w", err)
	}
	defer file.Close()

	// Filter subdomains based on options
	subdomains := filterSubdomains(result.Subdomains, options)

	// Write header
	fmt.Fprintf(file, "# Subdomain Enumeration Report: %s\n\n", result.Domain)
	fmt.Fprintf(file, "**Generated:** %s\n\n", time.Now().Format("2006-01-02 15:04:05"))
	fmt.Fprintf(file, "**Scan Date:** %s\n\n", result.Timestamp.Format("2006-01-02 15:04:05"))

	// Summary section
	fmt.Fprintf(file, "## Summary\n\n")
	fmt.Fprintf(file, "- **Total Subdomains:** %d\n", len(subdomains))
	if len(result.SourcesUsed) > 0 {
		fmt.Fprintf(file, "- **Sources Used:** %s\n", strings.Join(result.SourcesUsed, ", "))
	}

	// Count verification status
	aliveCount := 0
	deadCount := 0
	hasVerification := false

	for _, sub := range subdomains {
		if sub.Verified != nil {
			hasVerification = true
			if sub.Verified.Status == "alive" {
				aliveCount++
			} else if sub.Verified.Status == "dead" {
				deadCount++
			}
		}
	}

	if hasVerification {
		fmt.Fprintf(file, "- **Alive:** %d (%.1f%%)\n", aliveCount, float64(aliveCount)/float64(len(subdomains))*100)
		fmt.Fprintf(file, "- **Dead:** %d (%.1f%%)\n", deadCount, float64(deadCount)/float64(len(subdomains))*100)
	}

	fmt.Fprintf(file, "\n")

	// Source breakdown
	if len(result.Summary) > 0 {
		fmt.Fprintf(file, "## Source Breakdown\n\n")
		for source, count := range result.Summary {
			fmt.Fprintf(file, "- **%s:** %d subdomains\n", source, count)
		}
		fmt.Fprintf(file, "\n")
	}

	// Subdomains table
	fmt.Fprintf(file, "## Subdomains\n\n")

	if hasVerification {
		fmt.Fprintf(file, "| Subdomain | Status | HTTP | Title | Sources |\n")
		fmt.Fprintf(file, "|-----------|--------|------|-------|----------|\n")

		for _, sub := range subdomains {
			status := "-"
			httpInfo := "-"
			title := "-"

			if sub.Verified != nil {
				status = sub.Verified.Status

				if sub.Verified.HTTP != nil && sub.Verified.HTTP.Accessible {
					httpInfo = fmt.Sprintf("%d", sub.Verified.HTTP.StatusCode)
					if sub.Verified.HTTP.Title != "" {
						title = sub.Verified.HTTP.Title
						// Escape pipe characters in title
						title = strings.ReplaceAll(title, "|", "\\|")
						// Truncate long titles
						if len(title) > 50 {
							title = title[:47] + "..."
						}
					}
				}
			}

			sources := strings.Join(sub.DiscoveredBy, ", ")

			fmt.Fprintf(file, "| %s | %s | %s | %s | %s |\n",
				sub.Name, status, httpInfo, title, sources)
		}
	} else {
		fmt.Fprintf(file, "| Subdomain | Sources |\n")
		fmt.Fprintf(file, "|-----------|----------|\n")

		for _, sub := range subdomains {
			sources := strings.Join(sub.DiscoveredBy, ", ")
			fmt.Fprintf(file, "| %s | %s |\n", sub.Name, sources)
		}
	}

	// Footer
	fmt.Fprintf(file, "\n---\n\n")
	fmt.Fprintf(file, "*Report generated by Recontronic CLI*\n")

	return filePath, nil
}
